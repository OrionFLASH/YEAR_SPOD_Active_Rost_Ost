# Полная формализация логики расчета приростов для лаборатории режима (режима развития)

## Основные параметры и определения

Все дальнейшие разрезы логики строятся по трем осям (режимам лаборатории):

1. **Клиентский ключ/агрегация**:
   - По ИНН (агрегируем все строки по ИНН — аналитика на уровне клиента)
   - По ВКО (агрегируем по внутреннему коду объекта — если используется ВКО)

2. **Учет ТБ**:
   - Без учета ТБ (другими словами, вся сумма клиента или объекта просто складывается, независимо от разреза ТБ)
   - С учетом ТБ (каждая агрегация проводится отдельно по ТБ, чаще по доминантному ТБ для КМ или клиента)

3. **Метод определения КМ**:
   - КМ определяется на каждом шаге (в каждом файле — доминантный для клиента/ВКО в текущем файле и в прошлом файле отдельно)
   - КМ определяется как последний (КМ клиента/ВКО в текущем, если есть, если нет — в предыдущем периоде)

Комбинируя эти признаки, мы получаем основные типы логик расчета прироста.

---

## Варианты расчета (матрица комбинаций)

Пояснения:
- Везде "Сумма_текущая(...), Сумма_прошлая(...)" — это агрегированные суммы по ключу.
- "КМ" — клиентский менеджер (по Табельному номеру).
- "Доминантный КМ" — тот, у кого наибольшая сумма по данному ключу в файле.
- "Последний КМ" — КМ из текущего файла, если клиента/ВКО в нем нет — КМ из прошлого файла.

### Тип 1. По ВКО, без учета ТБ, КМ определяется в каждом файле отдельно (доминирующий в каждом файле)
- Для каждого ВКО в каждом файле определяем тот КМ, у которого максимальная сумма по данному ВКО.
- Весь объем ВКО в файле относится к этому КМ.
- Считаем:
    - Прирост по сочетанию (КМ_текущий, ВКО): Сумма_текущая(VKO, КМ_доминантный_текущий)
    - Прирост по сочетанию (КМ_прошлый, ВКО): Сумма_прошлая(VKO, КМ_доминантный_прошлый)
    - Если КМ не менялся — весь прирост по ВКО идет одному КМ.
    - Если КМ менялся, текущему начисляется плюс, прошлому минус.
- Итоговая агрегация по КМ.

### Тип 2. По ВКО, с учетом ТБ, КМ определяется по каждому файлу
- В каждом файле определяем для каждого ВКО одновременно его доминантного КМ и по этому ВКО-КМ его доминантный ТБ (где сумма ВКО у КМ максимальна).
- Все суммы ВКО в этом файле относятся на найденного КМ, причем только на его доминантном ТБ.
- Прирост формируется между этими закреплениями по ВКО-КМ-ТБ по аналогии с типом 1, но только при совпадении ТБ вклад идет в соответствующую строку.

### Тип 3. По ВКО, без учета ТБ, "последний" КМ
- Для каждого ВКО определяем последнего КМ: в текущем файле — доминантный КМ, иначе из прошлого. Весь прирост по ВКО всегда идет только на выбранного КМ (без разбиения).
- Итоговая агрегация по КМ.

### Тип 4. По ВКО, с учетом ТБ, "последний" КМ+TБ
- Для каждого ВКО определяем последнего КМ и, далее, основной ТБ этого КМ по ВКО (например, ТБ с максимальным объемом по ВКО у КМ).
- В прирост под этот КМ+ТБ залетят только те ВКО, которые могут быть однозначно сопоставлены с их доминантным ТБ КМ.
- Прирост идет только по этой связке.

### Тип 5. По ИНН, без учета ТБ, КМ определяется на каждом шаге (вариант 4 из предыдущей матрицы)
- Для каждого ИНН определяем доминантного КМ в текущем файле и в прошлом файле.
- Считаем суммы в каждом файле по ИНН, весь объем ИНН файла записываем выбранному КМ.
- Если КМ не меняется — прирост идет этому КМ. Если меняется — плюс/минус разным КМ.
- Итоговая агрегация по КМ.

### Тип 6. По ИНН, с учетом ТБ, КМ определяется на каждом шаге
- В каждом файле определяем доминантного КМ по ИНН, а потом для ИНН у этого КМ — доминантный ТБ (по максимальному объему).
- Если (КМ, ТБ) менялись — плюс и минус идут по новым/старым связкам.
- Прирост учитывается только если клиент в доминантном ТБ.
- Итог — агрегация по КМ+TБ.

### Тип 7. По ИНН, без учета ТБ, "последний" КМ (вариант 3 из предыдущей матрицы)
- Для клиента находим последнего КМ (по аналогии с вариантом 3 выше: если клиента нет в текущем, берем из прошлого).
- Весь прирост всегда идет на этого "последнего" КМ.
- Итоговая агрегация по КМ.

### Тип 8. По ИНН, с учетом ТБ, "последний" КМ+TБ
- Для клиента определяем последнего КМ.
- Для этого КМ ищем доминантный ТБ по клиенту (например, ТБ, где объем по ИНН у этого КМ максимален).
- Прирост идет только если клиент по ИНН находится у последнего КМ в его доминантном ТБ.
- Итоговая агрегация по КМ+TБ.

---

## Краткая таблица вариантов (Режим лаборатории)

| #   | Ключ агрегации | Учет ТБ  | КМ (логика)                | Итог агрегации         |
|-----|----------------|----------|----------------------------|-----------------------|
|  1  |     ВКО        |   Нет    | По каждому файлу           | по КМ                 |
|  2  |     ВКО        |   Да     | По каждому файлу           | по КМ+TБ              |
|  3  |     ВКО        |   Нет    | Последний (тек./прош.)     | по КМ                 |
|  4  |     ВКО        |   Да     | Последний (тек./прош.)     | по КМ+TБ              |
|  5  |     ИНН        |   Нет    | По каждому файлу           | по КМ                 |
|  6  |     ИНН        |   Да     | По каждому файлу           | по КМ+TБ              |
|  7  |     ИНН        |   Нет    | Последний (тек./прош.)     | по КМ                 |
|  8  |     ИНН        |   Да     | Последний (тек./прош.)     | по КМ+TБ              |

---

## Общие принципы/правила

- Для варианта с "по каждому файлу": каждое значение по ключу (ВКО/ИНН) в файле закрепляется ровно за одним КМ (и, если нужен ТБ — за одним ТБ у этого КМ).
- Для варианта с "последним" КМ: всегда для ключа(ВКО/ИНН) выбирается последний КМ из текущего, если нет — из предыдущего. Прирост по ключу всегда целиком идёт этому КМ, если не требуется особой детализации по смене КМ.
- Для ТБ: если ключ участвует только в доминантном для данного КМ ТБ, прирост по нему идёт в узел КМ+TБ. В остальных случаях прирост по ключу не учитывается в этой ячейке.
- Строгое требование: сумма всех итоговых приростов по КМ (и по КМ+TБ в вариантах с ТБ) должна совпадать с общим приростом файла.
- Всегда требуется аккуратная обработка отсутствующих значений (если ключа нет в файле — сумма считается нулевой).

---

**Эта методика позволяет сконструировать нужный аналитический сценарий под любую задачу лаборатории режима/развития и формализовать его для последующего кодирования либо анализа в BI.**

