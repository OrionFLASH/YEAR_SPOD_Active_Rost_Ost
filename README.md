# YEAR_SPOD_Active_Rost_Ost

## 1. Формулировка задачи и ТЗ
- Вся бизнес-логика должна находиться в единственном файле `src/main.py`. Используются только стандартные модули Python и базовый набор Anaconda 3.9 (`pandas`, `openpyxl` и пр.), установка дополнительных пакетов через `pip` запрещена.
- На вход поступают два XLSX-файла из каталога `IN`:
  - T-0: `АКТИВЫ 31-10-2025 (ОСТАТОК-V2).xlsx`;
  - T-1: `АКТИВЫ 31-12-2024 (ОСТАТОК-V2).xlsx`.
- Читается лист `Sheet1`, обязательные колонки и их бизнес-смысл:
  - `ТБ` — территориальный банк (строка);
  - `ГОСБ` — полное название ГОСБ (строка);
  - `ВКО` — ФИО клиентского менеджера (строка);
  - `Таб. номер ВКО` — табельный номер менеджера (строка фиксированной длины; длина и символ заполнения задаются параметрами);
  - `ИНН` — идентификатор клиента (строка фиксированной длины);
  - `Остаток срочной задолженности по основному долгу` — факт (число).
- Предварительная обработка:
  - строки с запрещёнными значениями удаляются (настройки задаются по колонкам);
  - текстовые поля нормализуются;
  - табельные номера и ИНН приводятся к заданной длине с лидирующими символами;
  - факт преобразуется к числовому типу с разделителем `,`.
- Ключевые требования по логике:
  - Рассчитать прирост `Прирост = Факт_T0 - Факт_T1` для набора листов `ID`, `ID+ТБ`, `ID+ТН`, `ID+ТБ+ТН`.
  - На каждом листе определить менеджеров двумя способами: «по каждому файлу» (доминирующий в T-0/T-1) и «последний» (T-0, иначе T-1, иначе заглушка `"Не найден КМ"` / `90000009`).
  - Сформировать листы агрегирования по уникальным `ТН+ВКО` и `ТН+ВКО+ТБ`, а также прямые своды по КМ.
  - Построить выгрузку СПОД (Excel и CSV) с колонками `MANAGER_PERSON_NUMBER`, `CONTEST_CODE`, `TOURNAMENT_CODE`, `CONTEST_DATE`, `PLAN_VALUE`, `FACT_VALUE`, `priority_type`. Форматы чисел (`0.00000`) и длины (`20` символов для табельного номера) фиксированы.
- Требования к форматированию Excel:
  - Заголовок — жирный, перенос по строкам; строки с данными — перенос по словам.
  - Ширина столбцов ограничена диапазоном 70–200 символов и подбирается по содержимому.
  - Включены `freeze panes` (ячейка `A2`) и автофильтр на всём диапазоне.
- Имена файлов (`OUT` и `log`) содержат префикс из настроек и суффикс `_YYYYMMDD_HH_MM`.
- Логирование ведётся в двух файлах (INFO и DEBUG). INFO дублируется в консоль, DEBUG содержит полные сообщения вида `дата время - [DEBUG] - ... [class: ... | def: ...]`.

## 2. Методология расчёта (матрица лаборатории режима)
Проект реализует восьмивариантную матрицу анализа, в которой комбинируются три независимые оси:
1. **Ключ агрегации** — клиент (`ИНН`) или объект (`ВКО`/`gosb`).
2. **Учёт территориального банка** — прирост может считаться суммарно или в разрезе доминантного ТБ.
3. **Логика выбора КМ** — доминирующий в каждом файле отдельно или «последний» (T-0, затем T-1).

### 2.1 Подробное описание типов

#### Тип 1. ВКО, без ТБ, КМ по каждому файлу
1. **Источник данных:** строка описывается ключом `gosb`. Все строки T-0 и T-1 приводятся к нормализованному виду (очистка, типы, формат ID).
2. **Группировка:** данные каждого файла агрегируются по `(gosb, Таб. номер, ВКО)` и суммируются `fact_value_clean`.
3. **Выбор доминантного КМ:** внутри каждого `gosb` выбирается табельный номер с максимальной суммой. При равнозначных результатах pandas `idxmax()` возвращает первую запись — по ТЗ это допустимо.
4. **Расчёт фактов:** отдельные таблицы `Факт_T0` и `Факт_T1` строятся через `aggregate_facts()` по ключу `gosb`.
5. **Объединение:** к агрегатам добавляем найденных КМ: `ВКО_T0`, `Таб. номер ВКО_T0` и аналогично для T-1.
6. **Прирост:** `Факт_T0 - Факт_T1`. Если значение > 0, оно относится к КМ из T-0; если < 0 — к КМ из T-1 (фиксируем, что прежний менеджер теряет объём).
7. **Итоговый лист:** результат группируется по `(Таб. номер ВКО, ВКО)`. ТБ в расчёт не включается.

#### Тип 2. ВКО, с ТБ, КМ по каждому файлу
1. **Ключ:** `(gosb, tb)` — та же логика, но объект разбивается на разрезы по ТБ.
2. **Поиск доминантного КМ:** как в типе 1.
3. **Определение доминантного ТБ:** среди строк выбранного табельного номера дополнительно выбираем ТБ с максимальным вкладом. Этот ТБ считается единственно корректным для привязки прироста.
4. **Прирост:** считается по ключу `gosb`, но в итог попадают только строки, где совпал доминантный ТБ выбранного КМ. Если у КМ было несколько ТБ с одинаковой суммой, в итог попадёт первый найденный.
5. **Итог:** группировка выполняется по `(Таб. номер ВКО, ТБ)`, что даёт структуру «КМ + его доминантный ТБ».

#### Тип 3. ВКО, без ТБ, последний КМ
1. **Ключ:** `gosb`.
2. **Подготовка:** так же, как в типе 1, формируются `ВКО_T0` и `ВКО_T1`.
3. **Актуальный КМ:** `build_latest_manager()` объединяет данные: если объект есть в T-0 — берём табельный номер оттуда; иначе из T-1; если отсутствует в обоих периодах, подставляем заглушку из настроек (`"Не найден КМ"`, `90000009`).
4. **Прирост:** всегда определяется как `Факт_T0 - Факт_T1`. Даже если объект отсутствует в T-1 (`Факт_T1 = 0`), прирост целиком идёт текущему КМ.
5. **Итог:** группировка только по табельному номеру/ФИО актуального КМ. Прошлые менеджеры не участвуют.

#### Тип 4. ВКО, с ТБ, последний КМ+ТБ
1. **Ключ:** `gosb`.
2. **Последний КМ:** аналогично типу 3.
3. **Доминантный ТБ актуального КМ:** рассматриваем строки только выбранного менеджера и определяем ТБ с максимальной суммой по данному `gosb`. Если менеджер встречается только в T-1, ТБ берётся из T-1.
4. **Прирост:** учитывается лишь в том случае, если объект можно однозначно привязать к найденному ТБ. Если по объекту разбросанные ТБ и ни один не доминирует, строка пропускается, чтобы не задвоить данные.
5. **Итог:** таблица содержит `(Таб. номер ВКО (выбранный), ТБ)` — фактически ролевую привязку актуального КМ к его «основному» ТБ.

#### Тип 5. ИНН, без ТБ, КМ по каждому файлу
1. **Ключ:** `client_id`.
2. **Группировка:** все строки агрегируются по `(client_id, Таб. номер, ВКО)` внутри каждого файла.
3. **Доминантный КМ:** выбираем табельный номер с максимальной суммой по клиенту. Это реализует требование «если у ИНН несколько ТН, берём тот, где сумма факта больше».
4. **Расчёт фактов:** `aggregate_facts()` строит `Факт_T0` и `Факт_T1` по клиенту. Если клиента нет в T-1, `Факт_T1 = 0`.
5. **Прирост:** `Факт_T0 - Факт_T1`, и он распределяется между КМ T-0 и T-1: текущий получает плюс, прошлый фиксирует минус (если они различаются).
6. **Итог:** группировка по табельному номеру без учёта ТБ.

#### Тип 6. ИНН, с ТБ, КМ по каждому файлу
1. **Ключ:** `(client_id, tb)`.
2. **Доминантный КМ:** как в типе 5.
3. **Доминантный ТБ:** среди строк выбранного КМ по клиенту ищем ТБ с максимальной суммой.
4. **Прирост:** в итог попадают только те записи, где совпали `ИНН`, табельный номер и выбранный доминантный ТБ. Так исключаем ситуацию, когда один КМ ведёт клиента сразу в нескольких ТБ.
5. **Итог:** группировка по `(Таб. номер ВКО, ТБ)`.

#### Тип 7. ИНН, без ТБ, последний КМ
1. **Ключ:** `client_id`.
2. **Доминантный КМ:** как в типе 5; далее передаём в `build_latest_manager()`.
3. **Последний КМ:** если клиент есть в T-0 — берём КМ оттуда, иначе из T-1, иначе заглушка.
4. **Прирост:** целиком приписывается последнему КМ. Если клиента нет в T-1, `Факт_T1 = 0`; если нет в T-0 — `Факт_T0 = 0`, и прирост будет отрицательным (клиент ушёл).
5. **Итог:** группировка по табельному номеру без ТБ. Именно этот сценарий чаще всего используется для формирования листа `SPOD`.

#### Тип 8. ИНН, с ТБ, последний КМ+ТБ
1. **Ключ:** `client_id`.
2. **Последний КМ:** как в типе 7.
3. **Доминантный ТБ последнего КМ:** анализируем строки клиента только у выбранного менеджера и определяем ТБ с максимальной суммой.
4. **Прирост:** учитываем только если клиента можно однозначно привязать к доминантному ТБ последнего КМ. Если у менеджера по этому клиенту несколько ТБ с одинаковым вкладом и нельзя выбрать доминанту, строка пропускается.
5. **Итог:** группировка по `(Таб. номер ВКО, ТБ)` актуального менеджера.

### 2.2 Таблица комбинаций

| # | Ключ агрегации | Учёт ТБ | Логика КМ | Итог |
|---|----------------|---------|-----------|------|
| 1 | ВКО            | Нет     | По каждому файлу | по КМ |
| 2 | ВКО            | Да      | По каждому файлу | по КМ+ТБ |
| 3 | ВКО            | Нет     | Последний        | по КМ |
| 4 | ВКО            | Да      | Последний        | по КМ+ТБ |
| 5 | ИНН            | Нет     | По каждому файлу | по КМ |
| 6 | ИНН            | Да      | По каждому файлу | по КМ+ТБ |
| 7 | ИНН            | Нет     | Последний        | по КМ |
| 8 | ИНН            | Да      | Последний        | по КМ+ТБ |

### 2.3 Как определяется доминантный КМ
1. Для заданного ключа (например, `ИНН`) выбираются все строки файла T-0 или T-1.
2. Формируется составной ключ «ключ + табельный номер + ФИО». Если менеджер уже входит в ключ (как в `ID_TN`), дополнительные поля не добавляются.
3. Таблицу группируют по этому составному ключу и суммируют `fact_value_clean`. Так получаем вклад каждого табельного номера.
4. Выбирается строка с максимальной суммой. Если несколько претендентов имеют одинаковое значение, pandas `idxmax()` возвращает первую запись — по ТЗ это считается допустимым решением.
5. Найденная пара (`ВКО`, `Таб. номер ВКО`) используется как доминантная для конкретного ключа и периода (T-0 или T-1). Далее эта информация участвует и в сценарии «по каждому файлу», и в вычислении актуального («последнего») менеджера.

Если по ключу присутствует только один табельный номер, он автоматически считается доминантным.

Каждый вариант формируется автоматически, сохраняется в Excel (листы `V1_...` – `V8_...`) и может использоваться как источник аналитики или вход для функции `build_spod_dataset()`. Для CSV выгрузки используется вариант, указанный в параметре `csv_variant`.
-
## 3. Описание решения
- Вся бизнес-логика реализована в одном файле `src/main.py` (как требовалось в задаче).
- Скрипт использует только стандартную библиотеку Python и пакет `pandas`, входящий в базовую поставку Anaconda.
- Входные файлы читаются из каталога `IN`, очищаются от запрещённых значений, нормализуются и агрегируются по четырём вариантам ключей (`ID`, `ID+ТБ`, `ID+ТН`, `ID+ТБ+ТН`).
- Для каждого варианта рассчитываются суммы фактов T-0 и T-1, приросты, менеджеры по данным обоих периодов и «актуальный» менеджер (приоритет у T-0, затем T-1, иначе заглушка).
- Дополнительно формируются листы с уникальными сочетаниями `ТН+ВКО` и `ТН+ВКО+ТБ`, а также выгрузка СПОД (лист Excel и CSV) с форматированием и заданными кодами конкурса.
- Реализована полная матрица из 8 вариантов расчета приростов согласно методологии лаборатории режима (см. `Docs/mode_lab_variant_matrix.md`). Комбинации: ВКО/ИНН × с ТБ/без ТБ × КМ по каждому файлу/последний КМ. Все варианты сохраняются в Excel на отдельных листах (`V1_ВКО_безТБ_КМ_пофайлу`, `V2_ВКО_сТБ_КМ_пофайлу` и т.д.), а в CSV записывается только выбранная комбинация (параметр `csv_variant` в настройках `spod`).
- Сохранение Excel выполняется через стандартный для Anaconda модуль `openpyxl`: pandas записывает данные, после чего форматирование (ширина столбцов, стили, freeze panes, фильтры и числовые форматы) применяется напрямую средствами `openpyxl`. Внешние зависимости, кроме базового набора Anaconda, не требуются.
- Исходные очищенные данные T-0 и T-1 записываются в Excel на листы `RAW_T0` и `RAW_T1` с человекочитаемыми заголовками и числовым столбцом `Факт (число)`.
- Логи ведутся раздельно для уровней INFO/DEBUG в каталоге `log`, в консоль выводится только INFO.

## 4. Структура каталогов
```
YEAR_SPOD_Active_Rost_Ost/
├── Docs/               # Папка для дополнительных материалов (после объединения документации может быть пустой)
├── IN/                 # Входные XLSX-файлы (T-0 и T-1)
├── OUT/                # Итоговые Excel и CSV файлы
├── log/                # Логи INFO/DEBUG
├── src/
│   ├── main.py         # Основной скрипт
│   └── Tests/README.md # Состояние автотестов
└── README.md           # Текущая документация (включает полное ТЗ и методологию)
```

## 5. Настройка окружения
1. Создать и активировать виртуальное окружение:
   ```bash
   cd ~/Desktop/MyProject/YEAR_SPOD_Active_Rost_Ost
   python3 -m venv .venv
   source .venv/bin/activate
   ```
2. Установки через `pip` не требуются (используется базовый набор Anaconda / стандартная библиотека).
3. (Опционально) Скопировать `.env.example` в `.env`, если планируется возвращение к внешней конфигурации. По умолчанию все параметры уже прошиты в `src/main.py` и сведены в дерево настроек.

## 6. Конфигурация
Вся настройка сведена в единую структуру (списки и вложенные словари), которую формирует функция `build_settings_tree()`:

1. **files** — описание входных XLSX.
   - `items` (`current`/`previous`): имя файла в `IN`, метка периода и лист. При замене файла достаточно изменить `file_name`, при смене листа — `sheet`.
   - `columns`: alias ↔ оригинальный заголовок в Excel. Чтобы добавить новое поле, внесите ещё один словарь.
2. **filters** — правила очистки (`drop_rules`), где указываются alias и набор запрещённых строк.
3. **defaults** — заглушки ФИО/табельного номера, которые подставляются, если ни T-0, ни T-1 не содержат менеджера.
4. **identifiers** — форматирование `manager_id` и `client_id` (символ заполнения и итоговая длина).
5. **spod** — параметры выгрузки (префикс имён, тема логов, плановое значение, приоритет и `fact_value_filter`, например `all`, `>=0`, `>1000`, `<=-50`, `==0`, `!=0`). Также содержит `csv_variant` (номер от 1 до 8) — выбранную комбинацию для CSV согласно матрице вариантов:
   - 1: ВКО, без ТБ, КМ по каждому файлу
   - 2: ВКО, с ТБ, КМ по каждому файлу
   - 3: ВКО, без ТБ, последний КМ
   - 4: ВКО, с ТБ, последний КМ
   - 5: ИНН, без ТБ, КМ по каждому файлу
   - 6: ИНН, с ТБ, КМ по каждому файлу
   - 7: ИНН, без ТБ, последний КМ
   - 8: ИНН, с ТБ, последний КМ
6. **contest** — коды конкурса/турнира и дата отчёта (`DD/MM/YYYY`).
7. **manager_views** — сценарии построения итоговых листов по менеджерам:
   - `source_variant`: какой вариант из блока `variants` брать (`ID_TN`, `ID_TB_TN` и т.д.).
   - `include_tb`: учитывать ли ТБ в ключе (True → группировка по ТБ+КМ).
   - `manager_mode`: как выбирать табельный номер: `latest` (T-0, затем T-1), `current_period` (только T-0) или `previous_period` (только T-1).
   - `use_for_spod`: если True, данный лист используется для формирования листа `SPOD` и CSV.
8. **direct_manager_views** — прямое суммирование по менеджеру (и опционально по ТБ) без опоры на клиентов (сценарий «весь факт на КМ»).
9. **growth_combinations** — комбинации аналитики, собранные поверх листов (например, `COMBO_VKO_NO_TB` опирается на `MANAGER_DIRECT` и даёт прирост «всё, что есть на КМ сейчас minus всё, что было» без учёта ТБ).
10. **variants** — основная сетка листов Excel «по клиентам» (служит источником данных для `manager_views`).

Любой параметр меняется прямо в соответствующем блоке структуры; остальные функции получают настройки автоматически.

## 7. Использование
1. Поместите исходные файлы в каталог `IN` под именами:
   - `АКТИВЫ 31-10-2025 (ОСТАТОК-V2).xlsx` (T-0)
   - `АКТИВЫ 31-12-2024 (ОСТАТОК-V2).xlsx` (T-1)
2. Запустите скрипт:
   ```bash
   python src/main.py
   ```
3. Результаты появятся в каталоге `OUT` в виде Excel и CSV файлов с суффиксом `_YYYYMMDD_HH_MM`. Лист `SPOD` и одноимённый CSV отсортированы по `FACT_VALUE` в соответствии с `fact_value_filter`. Excel также формирует:
   - `RAW_T0/RAW_T1` — очищенные исходные данные;
   - листы из `manager_views` (например, `TN_VKO`, `TN_VKO_TB`) — задают режим учёта ТБ и выбора КМ; один из них используется для SPOD;
   - листы из `direct_manager_views` (`MANAGER_DIRECT`, `MANAGER_DIRECT_TB`) — прямой подсчёт приростов по КМ без клиентских ключей;
   - листы из `growth_combinations`, включая `COMBO_VKO_NO_TB` — реализует сценарий «прирост по ВКО без учёта ТБ»;
   - матрица вариантов (`V1_ВКО_безТБ_КМ_пофайлу` ... `V8_ИНН_сТБ_КМ_последний`) — все 8 комбинаций расчета приростов согласно методологии лаборатории режима. В CSV записывается только выбранная комбинация (параметр `csv_variant` в настройках `spod`).
4. Логи формирования находятся в `log/INFO_*` и `log/DEBUG_*`.

## 8. Логирование
- INFO: ключевые этапы обработки, пишутся в файл `INFO_<topic>_<timestamp>.log` и дублируются в консоль.
- DEBUG: подробные сообщения для каждой функции с указанием класса и имени функции, записываются в `DEBUG_<topic>_<timestamp>.log`.
- Формат DEBUG строки: `YYYY-MM-DD HH:MM:SS - [DEBUG] - Сообщение [class: <...> | def: <...>]`.
- При возникновении исключений основной сценарий фиксирует сообщение в INFO и полную трассировку (в одну строку) в DEBUG, после чего пробрасывает ошибку наружу.

## 9. Список функций и примеры использования
| Функция / структура | Назначение | Пример вызова |
|--------------------|-----------|---------------|
| `build_settings_tree()` | Возвращает полную вложенную структуру настроек | `settings = build_settings_tree()` |
| `build_column_profiles(columns)` | Строит маппинг alias↔оригинал | `profiles = build_column_profiles(settings['files']['columns'])` |
| `build_drop_rules(rules)` | Преобразует список запретов к dict | `rules = build_drop_rules(settings['filters']['drop_rules'])` |
| `get_file_meta(file_section, key)` | Возвращает описание нужного Excel | `current = get_file_meta(settings['files'], 'current')` |
| `resolve_sheet_name(file_section, key)` | Определяет имя листа файла | `sheet = resolve_sheet_name(settings['files'], 'current')` |
| `parse_contest_date(contest)` | Переводит дату турнира к ISO | `iso = parse_contest_date(settings['contest'])` |
| `get_manager_columns(mode)` | Возвращает колонки для режима назначения КМ | `cols = get_manager_columns('latest')` |
| `build_filter_mask(series, condition)` | Формирует маску для фильтра `FACT_VALUE` | `mask = build_filter_mask(df['Прирост'], '>=0')` |
| `ensure_directories(paths)` | Создаёт недостающие каталоги | `ensure_directories([Path('IN')])` |
| `timestamp_suffix()` | Возвращает строку `_YYYYMMDD_HH_MM` | `suffix = timestamp_suffix()` |
| `format_identifier(value, length, char)` | Форматирует идентификаторы с лидирующими символами | `format_identifier('85461', 8, '0') -> '00085461'` |
| `safe_to_float(value)` | Безопасно приводит строку к `float` | `safe_to_float('43,51') -> 43.51` |
| `normalize_string(value)` | Очищает текстовое поле | `normalize_string('  ABC ') -> 'ABC'` |
| `build_logger(log_dir, topic)` | Возвращает функции `info`/`debug` | `logger = build_logger(Path('log'), 'spod')` |
| `log_info(logger, message)` | Записывает INFO без классов | `log_info(logger, 'Старт обработки')` |
| `log_debug(logger, message, class, func)` | Записывает DEBUG | `log_debug(logger, '...', 'Cleaner', 'drop_forbidden_rows')` |
| `read_source_file(path, sheet, columns, rules, ids, logger)` | Загружает Excel, нормализует данные | `df = read_source_file(file_path, 'Sheet1', rename_map, rules, identifiers, logger)` |
| `drop_forbidden_rows(df, rules, logger)` | Удаляет строки с запрещёнными значениями | `cleaned = drop_forbidden_rows(df, rules, logger)` |
| `aggregate_facts(df, keys, suffix, logger, variant)` | Суммирует факт по ключу | `agg = aggregate_facts(df, ['client_id'], 'T0', logger, 'ID')` |
| `select_best_manager(df, keys, logger, variant)` | Определяет менеджера с максимальным фактом | `best = select_best_manager(df, ['client_id'], logger, 'ID')` |
| `build_latest_manager(curr, prev, keys, defaults, ids, logger, variant)` | Комбинирует актуального менеджера | `latest = build_latest_manager(curr, prev, ['client_id'], defaults, identifiers, logger, 'ID')` |
| `assemble_variant_dataset(variant, keys, df_t0, df_t1, defaults, ids, logger)` | Строит итоговый набор данных для листа | `variant_tables['ID'] = assemble_variant_dataset('ID', ['client_id'], df_t0, df_t1, defaults, identifiers, logger)` |
| `build_manager_summary(df, include_tb, logger, name, manager_cols)` | Готовит свод по ТН/ВКО с выбранным режимом КМ | `summary = build_manager_summary(variant_tables['ID_TN'], False, logger, 'TN_VKO', get_manager_columns('latest'))` |
| `build_direct_manager_summary(df_t0, df_t1, include_tb, logger, name)` | Суммирует факты напрямую по КМ (и опционально ТБ) | `direct = build_direct_manager_summary(current_df, previous_df, False, logger, 'MANAGER_DIRECT')` |
| `format_excel_sheet(writer, sheet, df)` | Применяет оформление листа | `format_excel_sheet(writer, 'ID', df)` |
| `format_decimal_string(value)` | Приводит число к строке вида `0.00000` | `format_decimal_string(12.3) -> '12.30000'` |
| `build_spod_dataset(summary, spod_cfg, contest_cfg, ids, logger)` | Создаёт таблицу для СПОД/CSV | `spod = build_spod_dataset(summary, settings['spod'], settings['contest'], identifiers, logger)` |
| `rename_output_columns(df, alias_map)` | Возвращает русские подписи колонок | `rename_output_columns(table, profiles['alias_to_source'])` |
| `format_raw_sheet(df, alias_map)` | Подготавливает листы `RAW_T0/RAW_T1` | `raw = format_raw_sheet(current_df, profiles['alias_to_source'])` |
| `build_variant_matrix(df_t0, df_t1, defaults, ids, logger)` | Строит матрицу всех 8 вариантов расчета приростов (ВКО/ИНН × с ТБ/без ТБ × КМ по файлу/последний) | `matrix = build_variant_matrix(current_df, previous_df, defaults, identifiers, logger)` |
| `describe_variant7(df)` | Текстово поясняет механику варианта 7 | `print(describe_variant7())` |
| `process_project(project_root)` | Композиция всех шагов пайплайна | `process_project(Path.cwd())` |
| `main()` | Точка входа CLI | `python src/main.py` |

## 10. История версий
| Версия | Дата | Изменения |
|--------|------|-----------|
| 1.4.0 | 2025-11-25 | Реализована полная матрица из 8 вариантов расчета приростов согласно методологии лаборатории режима. Все варианты сохраняются в Excel на отдельных листах, в CSV записывается только выбранная комбинация (параметр `csv_variant` в настройках `spod`). |
| 1.3.0 | 2025-11-25 | Добавлены настройки для учёта ТБ и режима назначения КМ в итогах/SPOD; реализованы листы `manager_views`, `direct_manager_views`, а также комбинации (например, `COMBO_VKO_NO_TB`). |
| 1.2.1 | 2025-11-25 | В Excel добавлены листы `RAW_T0/RAW_T1` с исходными данными и числовым `Факт (число)`; описаны новые функции форматирования. |
| 1.2.0 | 2025-11-25 | Полный переход на функциональный стиль: настройки сведены в вложенные структуры, классы логера/конфигов заменены на функции, добавлен фильтр и сортировка FACT_VALUE. |
| 1.1.0 | 2025-11-24 | Значения из `.env` перенесены напрямую в `src/main.py`, убрано чтение внешнего файла конфигурации. |
| 1.0.0 | 2025-11-24 | Создан репозиторий, реализован основной сценарий расчёта приростов, добавлены логирование, шаблон `.env`, структура каталогов и документация. |

## 11. Дополнительные материалы
- `src/Tests/README.md` — инструкция по тестированию до появления автотестов.
- Прочие текстовые материалы (изначальное ТЗ и описание матрицы вариантов) полностью включены в этот README, поэтому отдельные файлы не требуются.

