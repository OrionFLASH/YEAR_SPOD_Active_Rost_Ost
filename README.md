# YEAR_SPOD_Active_Rost_Ost

## 1. Формулировка задачи и ТЗ
- Вся бизнес-логика должна находиться в единственном файле `src/main.py`. Используются только стандартные модули Python и базовый набор Anaconda 3.9 (`pandas`, `openpyxl` и пр.), установка дополнительных пакетов через `pip` запрещена.
- На вход поступают два XLSX-файла из каталога `IN`:
  - T-0: `АКТИВЫ 31-10-2025 (ОСТАТОК-V2).xlsx`;
  - T-1: `АКТИВЫ 31-12-2024 (ОСТАТОК-V2).xlsx`.
- Читается лист `Sheet1`, обязательные колонки и их бизнес-смысл:
  - `ТБ` — территориальный банк (строка);
  - `ГОСБ` — полное название ГОСБ (строка);
  - `ВКО` — ФИО клиентского менеджера (строка);
  - `Таб. номер ВКО` — табельный номер менеджера (строка фиксированной длины; длина и символ заполнения задаются параметрами);
  - `ИНН` — идентификатор клиента (строка фиксированной длины);
  - `Остаток срочной задолженности по основному долгу` — факт (число).
- Предварительная обработка:
  - строки с запрещёнными значениями удаляются (настройки задаются по колонкам);
  - текстовые поля нормализуются;
  - табельные номера и ИНН приводятся к заданной длине с лидирующими символами;
  - факт преобразуется к числовому типу с разделителем `,`.
- Ключевые требования по логике:
  - Рассчитать прирост `Прирост = Факт_T0 - Факт_T1` для набора листов `ID`, `ID+ТБ`, `ID+ТН`, `ID+ТБ+ТН`.
  - На каждом листе определить менеджеров двумя способами: «по каждому файлу» (доминирующий в T-0/T-1) и «последний» (T-0, иначе T-1, иначе заглушка `"Не найден КМ"` / `90000009`).
  - Сформировать листы агрегирования по уникальным `ТН+ВКО` и `ТН+ВКО+ТБ`, а также прямые своды по КМ.
  - Построить выгрузку СПОД (Excel и CSV) с колонками `MANAGER_PERSON_NUMBER`, `CONTEST_CODE`, `TOURNAMENT_CODE`, `CONTEST_DATE`, `PLAN_VALUE`, `FACT_VALUE`, `priority_type`. Форматы чисел (`0.00000`) и длины (`20` символов для табельного номера) фиксированы.
- Требования к форматированию Excel:
  - Заголовок — жирный, перенос по строкам; строки с данными — перенос по словам.
  - Ширина столбцов ограничена диапазоном 70–200 символов и подбирается по содержимому.
  - Включены `freeze panes` (ячейка `A2`) и автофильтр на всём диапазоне.
- Имена файлов (`OUT` и `log`) содержат префикс из настроек и суффикс `_YYYYMMDD_HH_MM`.
- Логирование ведётся в двух файлах (INFO и DEBUG). INFO дублируется в консоль, DEBUG содержит полные сообщения вида `дата время - [DEBUG] - ... [class: ... | def: ...]`.

## 2. Методология расчёта (матрица лаборатории режима)
Проект реализует восьмивариантную матрицу анализа, в которой комбинируются три независимые оси:
1. **Ключ агрегации** — клиент (`ИНН`) или объект (`ВКО`/`gosb`).
2. **Учёт территориального банка** — прирост может считаться суммарно или в разрезе доминантного ТБ.
3. **Логика выбора КМ** — доминирующий в каждом файле отдельно или «последний» (T-0, затем T-1).

### 2.1 Подробное описание типов

#### Тип 1. ВКО, без ТБ, КМ по каждому файлу
- **Источник данных.** На уровне объекта `gosb` формируем базовые факты `Факт_T0`, `Факт_T1` и прирост `Факт_T0 - Факт_T1`.
- **Поиск доминантов.** В каждом файле T-0/T-1 группируем строки по `(gosb, manager_id, manager_name)` и суммируем `fact_value_clean`. Табельный номер с максимальной суммой объявляется доминантным (при равенстве берётся первая запись).
- **Назначение прироста.** Положительная часть прироста закрепляется за доминантным КМ T-0, отрицательная — за доминантным КМ T-1. Так виден выигрыш текущего КМ и потеря предыдущего.
- **Результат.** Группировка по `(Таб. номер ВКО, ВКО)` без ТБ. Соответствует листу `V1_ВКО_безТБ_КМ_пофайлу`.

#### Тип 2. ВКО, с ТБ, КМ по каждому файлу
- **Ключ** — `(gosb, tb)`.
- **Доминантный КМ** определяется так же, как в типе 1.
- **Доминантный ТБ**: после выбора табельного номера анализируем только его строки и находим ТБ с максимальной суммой. Только эта связка `(gosb, manager_id, tb)` считается валидной.
- **Прирост** учитывается только по совпавшему ТБ; остальные строки отбрасываются, чтобы объект не «распался» на несколько ТБ.
- **Результат** — группировка по `(Таб. номер ВКО, ТБ)`; лист `V2_ВКО_сТБ_КМ_пофайлу`.

#### Тип 3. ВКО, без ТБ, последний КМ
- **Ключ** — `gosb`.
- **Доминирование**: получаем `ВКО_T0`, `ВКО_T1` аналогично типу 1.
- **Актуальный КМ**: `build_latest_manager()` берёт менеджера из T-0, при отсутствии — из T-1, при полном отсутствии — заглушку (`"Не найден КМ"`, `90000009`).
- **Прирост** полностью приписывается найденному актуальному менеджеру независимо от истории.
- **Результат** — группировка по табельному номеру без ТБ, лист `V3_ВКО_безТБ_КМ_последний`.

#### Тип 4. ВКО, с ТБ, последний КМ+ТБ
- **Ключ** — `gosb`.
- **Последний КМ** определяется как в типе 3.
- **Доминантный ТБ последнего КМ**: рассматриваем строки только этого КМ (из T-0 или T-1) и выбираем ТБ с максимальной суммой. Именно он считается «основным».
- **Прирост** фиксируется только если объект можно привязать к найденному ТБ; всё остальное игнорируется.
- **Результат** — группировка по `(Таб. номер ВКО, ТБ)` актуального менеджера; лист `V4_ВКО_сТБ_КМ_последний`.

#### Тип 5. ИНН, без ТБ, КМ по каждому файлу
- **Ключ** — `client_id`.
- **Доминирование**: в каждом файле суммируем `fact_value_clean` по `(client_id, manager_id, manager_name)`. Требование «если у ИНН несколько ТН, берём тот, где сумма больше» выполняется автоматически.
- **Факты**: `Факт_T0`, `Факт_T1` считаются по клиенту; отсутствие клиента в файле означает нулевой факт.
- **Прирост** делится между доминантными КМ T-0 и T-1 (аналогично типу 1).
- **Результат** — группировка по табельному номеру без ТБ; лист `V5_ИНН_безТБ_КМ_пофайлу`.

#### Тип 6. ИНН, с ТБ, КМ по каждому файлу
- **Ключ** — `(client_id, tb)`.
- **Доминирование** — как в типе 5.
- **Доминантный ТБ**: у выбранного КМ определяется ТБ с максимальным вкладом.
- **Прирост** учитывается только по строкам, где совпали `ИНН`, табельный номер и доминантный ТБ.
- **Результат** — группировка по `(Таб. номер ВКО, ТБ)`; лист `V6_ИНН_сТБ_КМ_пофайлу`.

#### Тип 7. ИНН, без ТБ, последний КМ
- **Сбор данных**: `assemble_variant_dataset("V7...", ["client_id"], ...)` формирует строки с `Факт_T0`, `Факт_T1`, `Прирост`, доминантами каждого периода и полями `ВКО_Актуальный`, `Таб. номер ВКО_Актуальный`.
- **Доминирование**: если у клиента несколько менеджеров в одном файле, выбирается тот, у кого суммарный факт больше.
- **Последний КМ**: `build_latest_manager()` применяет приоритет T-0 → T-1 → заглушка. Даже если в T-0 и T-1 менеджеры разные, итоговый прирост целиком записывается актуальному владельцу.
- **Агрегация**: `build_manager_summary(..., include_tb=False, manager_columns={"id": "Таб. номер ВКО_Актуальный", ...})` суммирует факты и прирост по актуальным КМ.
- **Смысл**: сценарий отвечает на вопрос «какой прирост несёт на себе каждый текущий КМ по всем своим клиентам, независимо от истории».
- **Результат** — лист `V7_ИНН_безТБ_КМ_последний`; при `csv_variant = 7` он становится основой для SPOD/CSV (после фильтра и сортировки).

#### Тип 8. ИНН, с ТБ, последний КМ+ТБ
- **Ключ** — `client_id`.
- **Последний КМ** определяется как в типе 7.
- **Доминантный ТБ**: анализируем только строки клиента у последнего КМ (из T-0 или T-1) и выбираем ТБ с максимальной суммой.
- **Прирост** учитывается лишь тогда, когда клиента можно однозначно отнести к найденному ТБ. Если ТБ определить нельзя или он неоднозначен, строка исключается.
- **Результат** — группировка по `(Таб. номер ВКО, ТБ)` актуального менеджера; лист `V8_ИНН_сТБ_КМ_последний`.

### 2.2 Таблица комбинаций

| # | Ключ агрегации | Учёт ТБ | Логика КМ | Итог |
|---|----------------|---------|-----------|------|
| 1 | ВКО            | Нет     | По каждому файлу | по КМ |
| 2 | ВКО            | Да      | По каждому файлу | по КМ+ТБ |
| 3 | ВКО            | Нет     | Последний        | по КМ |
| 4 | ВКО            | Да      | Последний        | по КМ+ТБ |
| 5 | ИНН            | Нет     | По каждому файлу | по КМ |
| 6 | ИНН            | Да      | По каждому файлу | по КМ+ТБ |
| 7 | ИНН            | Нет     | Последний        | по КМ |
| 8 | ИНН            | Да      | Последний        | по КМ+ТБ |

### 2.3 Как определяется доминантный КМ
1. Для заданного ключа (например, `ИНН`) выбираются все строки файла T-0 или T-1.
2. Формируется составной ключ «ключ + табельный номер + ФИО». Если менеджер уже входит в ключ (как в `ID_TN`), дополнительные поля не добавляются.
3. Таблицу группируют по этому составному ключу и суммируют `fact_value_clean`. Так получаем вклад каждого табельного номера.
4. Выбирается строка с максимальной суммой. Если несколько претендентов имеют одинаковое значение, pandas `idxmax()` возвращает первую запись — по ТЗ это считается допустимым решением.
5. Найденная пара (`ВКО`, `Таб. номер ВКО`) используется как доминантная для конкретного ключа и периода (T-0 или T-1). Далее эта информация участвует и в сценарии «по каждому файлу», и в вычислении актуального («последнего») менеджера.

Если по ключу присутствует только один табельный номер, он автоматически считается доминантным.

Каждый вариант формируется автоматически, сохраняется в Excel (листы `V1_...` – `V8_...`) и может использоваться как источник аналитики или вход для функции `build_spod_dataset()`. Для CSV выгрузки используется вариант, указанный в параметре `csv_variant`.
-
## 3. Описание решения
- Вся бизнес-логика реализована в одном файле `src/main.py` (как требовалось в задаче).
- Скрипт использует только стандартную библиотеку Python и пакет `pandas`, входящий в базовую поставку Anaconda.
- Входные файлы читаются из каталога `IN`, очищаются от запрещённых значений, нормализуются и агрегируются по четырём вариантам ключей (`ID`, `ID+ТБ`, `ID+ТН`, `ID+ТБ+ТН`).
- Для каждого варианта рассчитываются суммы фактов T-0 и T-1, приросты, менеджеры по данным обоих периодов и «актуальный» менеджер (приоритет у T-0, затем T-1, иначе заглушка).
- Дополнительно формируются листы с уникальными сочетаниями `ТН+ВКО` и `ТН+ВКО+ТБ`, а также выгрузка СПОД (лист Excel и CSV) с форматированием и заданными кодами конкурса.
- Реализована полная матрица из 8 вариантов расчета приростов согласно методологии лаборатории режима (см. `Docs/mode_lab_variant_matrix.md`). Комбинации: ВКО/ИНН × с ТБ/без ТБ × КМ по каждому файлу/последний КМ. Для аналитических нужд они рассчитываются всегда, но в основной Excel-файл попадают только листы, перечисленные в блоке `report_layout` (по умолчанию это источники `RAW_T0/RAW_T1`, промежуточные агрегаты `ID/ID_TB/ID_TN/ID_TB_TN`, итоговые представления `TN_VKO` и `TN_VKO_TB`, а также выбранные листы СПОД). Остальные листы можно включить, добавив их названия в `report_layout`.
- Сохранение Excel выполняется через стандартный для Anaconda модуль `openpyxl`: pandas записывает данные, после чего форматирование (ширина столбцов, стили, freeze panes, фильтры и числовые форматы) применяется напрямую средствами `openpyxl`. Внешние зависимости, кроме базового набора Anaconda, не требуются.
- Исходные очищенные данные T-0 и T-1 записываются в Excel на листы `RAW_T0` и `RAW_T1` с человекочитаемыми заголовками и числовым столбцом `Факт (число)`.
- Логи ведутся раздельно для уровней INFO/DEBUG в каталоге `log`, в консоль выводится только INFO.

## 4. Структура каталогов
```
YEAR_SPOD_Active_Rost_Ost/
├── Docs/               # Папка для дополнительных материалов (после объединения документации может быть пустой)
├── IN/                 # Входные XLSX-файлы (T-0 и T-1)
├── OUT/                # Итоговые Excel и CSV файлы
├── log/                # Логи INFO/DEBUG
├── src/
│   ├── main.py         # Основной скрипт
│   └── Tests/README.md # Состояние автотестов
└── README.md           # Текущая документация (включает полное ТЗ и методологию)
```

## 5. Настройка окружения
1. Создать и активировать виртуальное окружение:
   ```bash
   cd ~/Desktop/MyProject/YEAR_SPOD_Active_Rost_Ost
   python3 -m venv .venv
   source .venv/bin/activate
   ```
2. Установки через `pip` не требуются (используется базовый набор Anaconda / стандартная библиотека).
3. (Опционально) Скопировать `.env.example` в `.env`, если планируется возвращение к внешней конфигурации. По умолчанию все параметры уже прошиты в `src/main.py` и сведены в дерево настроек.

## 6. Конфигурация
Вся настройка сведена в единую структуру (списки и вложенные словари), которую формирует функция `build_settings_tree()`:

1. **files** — описание входных XLSX.
   - `items` (`current`/`previous`): имя файла в `IN`, метка периода и лист. При замене файла достаточно изменить `file_name`, при смене листа — `sheet`.
   - `columns`: alias ↔ оригинальный заголовок в Excel. Чтобы добавить новое поле, внесите ещё один словарь.
2. **filters** — правила очистки (`drop_rules`), где указываются alias и набор запрещённых строк.
3. **defaults** — заглушки ФИО/табельного номера, которые подставляются, если ни T-0, ни T-1 не содержат менеджера.
4. **identifiers** — форматирование `manager_id` и `client_id` (символ заполнения и итоговая длина).
5. **spod** — префикс имён Excel/CSV и тема логов. Остальные параметры выгрузки задаются индивидуально для каждого варианта в блоке `spod_variants`.
6. **percentile_views** — список дополнительной аналитики по процентным рангам. Каждый элемент указывает:
   - `source_type`/`source_name` — какую таблицу использовать (например, `manager_view` `TN_VKO`);
   - `value_column` — показатель для ранжирования (по умолчанию `Прирост`);
   - `tb_column` — колонка с ТерБанком (если нужна аналитика «внутри ТБ`);
   - `metric_column` — одна из колонок, описанных в `Docs/percentile_logic.md` (`Обогнал_всего_%`, `Обогнали_меня_ТерБанк_≥0_%` и т.д.);
   - `sheet_name`/`metric_label` — имя листа и подпись колонки в Excel.
7. **spod_variants** — перечень выгрузок SPOD. Для каждой указываются:
   - `source_type`/`source_name` — таблица-источник (может быть как `manager_view`, так и результат процентильного расчёта);
   - `calc_sheet_name` — имя листа с расчётами (если нужно выделить отдельную вкладку);
   - `spod_sheet_name` — имя листа с итоговой таблицей SPOD;
   - `value_column`, `fact_value_filter`, `plan_value`, `priority`, `contest_code`, `tournament_code`, `contest_date` — индивидуальные параметры выгрузки;
   - `include_in_csv` — признак, что вариант включается в объединённый CSV;
   - при необходимости можно добавить `csv_label`, чтобы отличать варианты при постобработке.
8. **manager_views** — сценарии построения итоговых листов по менеджерам:
   - `source_variant`: какой вариант из блока `variants` брать (`ID_TN`, `ID_TB_TN` и т.д.).
   - `include_tb`: учитывать ли ТБ в ключе (True → группировка по ТБ+КМ).
   - `manager_mode`: как выбирать табельный номер: `latest` (T-0, затем T-1), `current_period` (только T-0) или `previous_period` (только T-1).
9. **direct_manager_views** — прямое суммирование по менеджеру (и опционально по ТБ) без опоры на клиентов (сценарий «весь факт на КМ»).
10. **growth_combinations** — комбинации аналитики, собранные поверх листов (например, `COMBO_VKO_NO_TB` опирается на `MANAGER_DIRECT` и даёт прирост «всё, что есть на КМ сейчас minus всё, что было» без учёта ТБ).
11. **variants** — основная сетка листов Excel «по клиентам» (служит источником данных для `manager_views`).

12. **report_layout** — список масок, управляющих тем, какие листы попадут в итоговый Excel:
    - `variant_sheets`, `manager_view_sheets`, `direct_manager_sheets`, `growth_combination_sheets`, `variant_matrix_sheets`, `percentile_sheets`, `calc_sheets`, `spod_variants`, `raw_sheets`.
    - Значение `null` (ключ отсутствует) означает «не ограничивать» и ведёт себя как прежняя версия (пишутся все листы блока).
    - Пустой список отключает блок полностью. Набор строк задаёт точный whitelisting листов, которые должны появиться в книге.

Любой параметр меняется прямо в соответствующем блоке структуры; остальные функции получают настройки автоматически.

## 7. Использование
1. Поместите исходные файлы в каталог `IN` под именами:
   - `АКТИВЫ 31-10-2025 (ОСТАТОК-V2).xlsx` (T-0)
   - `АКТИВЫ 31-12-2024 (ОСТАТОК-V2).xlsx` (T-1)
2. Запустите скрипт:
   ```bash
   python src/main.py
   ```
3. Результаты появятся в каталоге `OUT` в виде Excel и CSV файлов с суффиксом `_YYYYMMDD_HH_MM`. Каждый сценарий из `spod_variants` получает:
   - расчётный лист `calc_sheet_name` (если он включён в `report_layout`) с исходной таблицей;
   - лист `spod_sheet_name` с подготовленной таблицей SPOD (лист попадает в книгу только если сам сценарий разрешён в `report_layout`).

   CSV-файл содержит объединённые данные всех вариантов, где `include_in_csv=True`. Excel формирует только те листы, которые перечислены в блоке `report_layout`. Настройки по умолчанию:
   - `RAW_T0/RAW_T1` — очищенные исходные данные;
   - `ID`, `ID_TB`, `ID_TN`, `ID_TB_TN` — базовые листы первоисточников;
   - `TN_VKO`, `TN_VKO_TB` — промежуточные итоговые представления для выбранных сценариев КМ;
   - `CALC_V7`, `CALC_V7_PERC_ALL` и соответствующие листы `SPOD_V7`, `SPOD_V7_PERC_ALL` — расчётные и итоговые листы СПОД.
   Чтобы добавить другие листы (например, прямые своды или процентильные представления), укажите их имена в соответствующих массивах `report_layout`.
4. Логи формирования находятся в `log/INFO_*` и `log/DEBUG_*`.

## 8. Логирование
- INFO: ключевые этапы обработки, пишутся в файл `INFO_<topic>_<timestamp>.log` и дублируются в консоль.
- DEBUG: подробные сообщения для каждой функции с указанием класса и имени функции, записываются в `DEBUG_<topic>_<timestamp>.log`.
- Формат DEBUG строки: `YYYY-MM-DD HH:MM:SS - [DEBUG] - Сообщение [class: <...> | def: <...>]`.
- При возникновении исключений основной сценарий фиксирует сообщение в INFO и полную трассировку (в одну строку) в DEBUG, после чего пробрасывает ошибку наружу.

## 9. Список функций и примеры использования
| Функция / структура | Назначение | Пример вызова |
|--------------------|-----------|---------------|
| `build_settings_tree()` | Возвращает полную вложенную структуру настроек | `settings = build_settings_tree()` |
| `build_column_profiles(columns)` | Строит маппинг alias↔оригинал | `profiles = build_column_profiles(settings['files']['columns'])` |
| `build_drop_rules(rules)` | Преобразует список запретов к dict | `rules = build_drop_rules(settings['filters']['drop_rules'])` |
| `get_file_meta(file_section, key)` | Возвращает описание нужного Excel | `current = get_file_meta(settings['files'], 'current')` |
| `resolve_sheet_name(file_section, key)` | Определяет имя листа файла | `sheet = resolve_sheet_name(settings['files'], 'current')` |
| `parse_contest_date(date_str)` | Переводит дату турнира `DD/MM/YYYY` к ISO | `iso = parse_contest_date('31/10/2025')` |
| `get_manager_columns(mode)` | Возвращает колонки для режима назначения КМ | `cols = get_manager_columns('latest')` |
| `build_filter_mask(series, condition)` | Формирует маску для фильтра `FACT_VALUE` | `mask = build_filter_mask(df['Прирост'], '>=0')` |
| `ensure_directories(paths)` | Создаёт недостающие каталоги | `ensure_directories([Path('IN')])` |
| `timestamp_suffix()` | Возвращает строку `_YYYYMMDD_HH_MM` | `suffix = timestamp_suffix()` |
| `format_identifier(value, length, char)` | Форматирует идентификаторы с лидирующими символами | `format_identifier('85461', 8, '0') -> '00085461'` |
| `safe_to_float(value)` | Безопасно приводит строку к `float` | `safe_to_float('43,51') -> 43.51` |
| `normalize_string(value)` | Очищает текстовое поле | `normalize_string('  ABC ') -> 'ABC'` |
| `build_logger(log_dir, topic)` | Возвращает функции `info`/`debug` | `logger = build_logger(Path('log'), 'spod')` |
| `log_info(logger, message)` | Записывает INFO без классов | `log_info(logger, 'Старт обработки')` |
| `log_debug(logger, message, class, func)` | Записывает DEBUG | `log_debug(logger, '...', 'Cleaner', 'drop_forbidden_rows')` |
| `read_source_file(path, sheet, columns, rules, ids, logger)` | Загружает Excel, нормализует данные | `df = read_source_file(file_path, 'Sheet1', rename_map, rules, identifiers, logger)` |
| `drop_forbidden_rows(df, rules, logger)` | Удаляет строки с запрещёнными значениями | `cleaned = drop_forbidden_rows(df, rules, logger)` |
| `aggregate_facts(df, keys, suffix, logger, variant)` | Суммирует факт по ключу | `agg = aggregate_facts(df, ['client_id'], 'T0', logger, 'ID')` |
| `select_best_manager(df, keys, logger, variant)` | Определяет менеджера с максимальным фактом | `best = select_best_manager(df, ['client_id'], logger, 'ID')` |
| `build_latest_manager(curr, prev, keys, defaults, ids, logger, variant)` | Комбинирует актуального менеджера | `latest = build_latest_manager(curr, prev, ['client_id'], defaults, identifiers, logger, 'ID')` |
| `assemble_variant_dataset(variant, keys, df_t0, df_t1, defaults, ids, logger)` | Строит итоговый набор данных для листа | `variant_tables['ID'] = assemble_variant_dataset('ID', ['client_id'], df_t0, df_t1, defaults, identifiers, logger)` |
| `build_manager_summary(df, include_tb, logger, name, manager_cols)` | Готовит свод по ТН/ВКО с выбранным режимом КМ | `summary = build_manager_summary(variant_tables['ID_TN'], False, logger, 'TN_VKO', get_manager_columns('latest'))` |
| `build_direct_manager_summary(df_t0, df_t1, include_tb, logger, name)` | Суммирует факты напрямую по КМ (и опционально ТБ) | `direct = build_direct_manager_summary(current_df, previous_df, False, logger, 'MANAGER_DIRECT')` |
| `format_excel_sheet(writer, sheet, df)` | Применяет оформление листа | `format_excel_sheet(writer, 'ID', df)` |
| `format_decimal_string(value)` | Приводит число к строке вида `0.00000` | `format_decimal_string(12.3) -> '12.30000'` |
| `append_percentile_columns(table, value_column, tb_column)` | Добавляет восемь колонок процентных рангов «обогнал/обогнали» (см. `Docs/percentile_logic.md`) | `augmented = append_percentile_columns(summary, value_column='Прирост', tb_column='ТБ')` |
| `build_spod_dataset(table, value_column, fact_filter, plan, priority, contest_codes, ids, logger, name)` | Создаёт таблицу SPOD для конкретного сценария (`spod_variants`) | `spod = build_spod_dataset(summary, value_column='Прирост', fact_value_filter='>0', plan_value=0, priority='1', contest_code='...', tournament_code='...', contest_date='31/10/2025', identifiers=identifiers, logger=logger, dataset_name='SPOD_V7')` |
| `rename_output_columns(df, alias_map)` | Возвращает русские подписи колонок | `rename_output_columns(table, profiles['alias_to_source'])` |
| `format_raw_sheet(df, alias_map)` | Подготавливает листы `RAW_T0/RAW_T1` | `raw = format_raw_sheet(current_df, profiles['alias_to_source'])` |
| `build_variant_matrix(df_t0, df_t1, defaults, ids, logger)` | Строит матрицу всех 8 вариантов расчета приростов (ВКО/ИНН × с ТБ/без ТБ × КМ по файлу/последний) | `matrix = build_variant_matrix(current_df, previous_df, defaults, identifiers, logger)` |
| `describe_variant7(df)` | Текстово поясняет механику варианта 7 | `print(describe_variant7())` |
| `process_project(project_root)` | Композиция всех шагов пайплайна | `process_project(Path.cwd())` |
| `main()` | Точка входа CLI | `python src/main.py` |

## 10. История версий
| Версия | Дата | Изменения |
|--------|------|-----------|
| 1.6.0 | 2025-11-26 | Добавлен блок `report_layout`, который ограничивает содержимое Excel-файла (оставлены только RAW-листы, первоисточники `ID/ID_TB/ID_TN/ID_TB_TN`, промежуточные `TN_VKO/TN_VKO_TB` и выбранные листы СПОД). Остальные листы можно включать адресно через whitelists. |
| 1.5.0 | 2025-11-26 | Встроена методика процентных рангов (`Docs/percentile_logic.md`) для любых сценариев (`percentile_views`), реализована система `spod_variants` (отдельные настройки SPOD/CSV для каждой комбинации, свой набор листов в Excel, объединение нескольких сценариев в один CSV). Удалены глобальные настройки конкурса — теперь коды/дата/фильтры задаются в каждой записи `spod_variants`. |
| 1.4.0 | 2025-11-25 | Реализована полная матрица из 8 вариантов расчета приростов согласно методологии лаборатории режима. Все варианты сохраняются в Excel на отдельных листах, в CSV записывается только выбранная комбинация (параметр `csv_variant` в настройках `spod`). |
| 1.3.0 | 2025-11-25 | Добавлены настройки для учёта ТБ и режима назначения КМ в итогах/SPOD; реализованы листы `manager_views`, `direct_manager_views`, а также комбинации (например, `COMBO_VKO_NO_TB`). |
| 1.2.1 | 2025-11-25 | В Excel добавлены листы `RAW_T0/RAW_T1` с исходными данными и числовым `Факт (число)`; описаны новые функции форматирования. |
| 1.2.0 | 2025-11-25 | Полный переход на функциональный стиль: настройки сведены в вложенные структуры, классы логера/конфигов заменены на функции, добавлен фильтр и сортировка FACT_VALUE. |
| 1.1.0 | 2025-11-24 | Значения из `.env` перенесены напрямую в `src/main.py`, убрано чтение внешнего файла конфигурации. |
| 1.0.0 | 2025-11-24 | Создан репозиторий, реализован основной сценарий расчёта приростов, добавлены логирование, шаблон `.env`, структура каталогов и документация. |

## 11. Дополнительные материалы
- `Docs/percentile_logic.md` — подробная методика расчёта процентных рангов («обогнал»/«обогнали», глобально и внутри ТерБанка, с фильтром ≥0). Код и комментарии в `src/main.py` ссылаются на этот документ.
- `src/Tests/README.md` — инструкция по тестированию до появления автотестов.
- Прочие текстовые материалы (изначальное ТЗ и описание матрицы вариантов) полностью включены в этот README, поэтому отдельные файлы не требуются.

